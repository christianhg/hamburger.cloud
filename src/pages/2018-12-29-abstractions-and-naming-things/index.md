---
path: '/abstractions-and-naming-things'
date: '2018-12-29'
title: 'Abstractions and Naming Things'
lead: "As I gain experience as a programmer, I'm getting more certain that the hardest part of my job isn't actual programming or problem-solving at all. Communication is."
---

Recently I talked to my father-in-law about the benefits of a [Chromebook](https://en.wikipedia.org/wiki/Chromebook). Since a Chromebook barely has local storage I was quick to mention "the cloud" only to realise that this name meant nothing to him. In order for my father-in-law to get an idea of what Chromebooks are, I had to peal off a layer of abstraction and start with explaining "the cloud".

In the end I managed to recommend him a new laptop, but later that night it hit  me: Names are just abstractions, and every conversation is built upon layers of layers of abstraction. Before we can even begin to have a meaningful, effective conversation we need a baseline of names in our common vocabulary.

---

In my job as a front-end developer I communicate with product owners, sales people, back-end developers, etc., through a variety of channels. However, the majority of my time is spent communicating with my team of fellow front-end developers through the code we write. Our common languages are HTML, CSS, JavaScript and English, but our vocabularies differ and it's easy for an individual to misstep and take a certain name, abstraction or concept for given.

When engaging in a conversation we make assumptions about the vocabulary of those whom we converse with. Most of the time we're right, but other times we fail even in our most noble efforts to communicate clearly.

The team is an inspiring mix of nationalities, backgrounds, educations and favourite programming paradigms where everyone brings something of their own to the table. Like with most things, this is a double-edged sword that lets us explore solutions that would otherwise not have been thought of in isolation. On the other hand, every one of these solutions needs to be reverse-engineered and re-understood by someone else later in the never-ending, asynchronous conversation that is code.

---

So what's my point?

I think, my point is that programming can be unbearably hard. Because programming is not only about problem-solving and closing issues - it's about communication. Just like we have little control over the audience of our apps (their resolution, network connection, etc.), we have little control over the audience of our code. People come and go, and products and projects outlive their founding programmers. New people will eventually come along, and they'll be left without your guidance, trying to piece together the remains of your castle of code. Hopefully they read English along with the given programming language, but chances are that they are nothing like yourself.

---

What *w*


* **Write dumb code**
* **Emphasise with your audience**
* **Reuse proven names and ideas**


---
---

What makes a good name?

Dumb code

I remember diving

I have a vague understanding of what "the cloud" means.

Good names can be looked up

Documentation

Correct English

Use simple names

Reuse names

Use less names (FP \o/)

Think about your audience (if that's even possible.)

OOP or FP?

The baseline is the programming language itself

```
Insert example of imperative map and declarative map
```

Modal vs. Dialog

Programming is hard

Sometimes we take names for given. When talking to my father-in-law I wrongfully assumed that we had a shared understanding of "the cloud". Luckily, he stopped me and had me explain "the cloud", a foreign word to him, in more detail. This was great, but the conversation suffered. It got off-balance. Like in a code review and I suddenly stumble upon `.transform` instead of `.map`.

But what if he hadn't? What if he couldn't? What if our conversation was async? Like code.

The names we chose have more impact than we think.

Be generous when you assume other people know what your abstractions mean.
